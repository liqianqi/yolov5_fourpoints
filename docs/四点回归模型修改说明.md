# YOLOv5 四点回归模型修改说明

## 目录

| 章节              | 文档位置                    | 源文件                                                |
| ----------------- | --------------------------- | ----------------------------------------------------- |
| 1. 数据集标签格式 | [§1](#1-数据集标签格式)     | [`convert_labels.py`](../convert_labels.py)           |
| 2. 模型结构       | [§2](#2-模型结构修改)       | [`models/yolo.py`](../models/yolo.py)                 |
| 3. 数据加载       | [§3](#3-数据加载修改)       | [`utils/dataloaders.py`](../utils/dataloaders.py)     |
| 4. 数据增强       | [§4](#4-数据增强修改)       | [`utils/augmentations.py`](../utils/augmentations.py) |
| 5. 损失函数       | [§5](#5-损失函数修改)       | [`utils/loss.py`](../utils/loss.py)                   |
| 6. 多边形 IoU     | [§6](#6-多边形-iou-实现)    | [`utils/general.py`](../utils/general.py)             |
| 7. NMS            | [§7](#7-nms-修改)           | [`utils/general.py`](../utils/general.py)             |
| 8. 推理可视化     | [§8](#8-推理可视化修改)     | [`detect.py`](../detect.py)                           |
| 9. 验证脚本       | [§9](#9-验证脚本修改)       | [`val.py`](../val.py)                                 |
| 10. 训练可视化    | [§10](#10-训练可视化修改)   | [`utils/plots.py`](../utils/plots.py)                 |
| 11. PyTorch 修复  | [§11](#11-pytorch-警告修复) | [`train.py`](../train.py)                             |
| 12. 文件总结      | [§12](#12-文件修改总结)     | —                                                     |
| 13. 使用方法      | [§13](#13-使用方法)         | —                                                     |

---

## 概述

本文档详细说明了将标准 YOLOv5（矩形框检测）修改为四点回归模型（四边形检测）所涉及的所有代码变更。

### 核心变化

| 项目     | 原始 YOLOv5                  | 四点回归模型                              |
| -------- | ---------------------------- | ----------------------------------------- |
| 标注格式 | `cls cx cy w h` (5列)        | `cls x1 y1 x2 y2 x3 y3 x4 y4` (9列)       |
| 输出格式 | 矩形框 `[x1, y1, x2, y2]`    | 四边形 `[x1, y1, x2, y2, x3, y3, x4, y4]` |
| 模型输出 | `nc + 5` (类别 + xywh + obj) | `nc + 9` (类别 + 8个坐标 + obj)           |
| IoU 计算 | 矩形框 IoU                   | 多边形 IoU                                |
| NMS      | 矩形框 NMS                   | 多边形 NMS (可选)                         |

---

<a id="1-数据集标签格式"></a>

## 1. 数据集标签格式

### 原始格式 (15列，含矩形框+关键点)

```
cls cx cy w h x1 y1 x2 y2 x3 y3 x4 y4 [-1 -1]
```

### 新格式 (9列，纯四点)

```
cls x1 y1 x2 y2 x3 y3 x4 y4
```

<a id="convert-labelspy"></a>

### 转换脚本

创建了 [`convert_labels.py`](../convert_labels.py) 用于批量转换：

```python
# convert_labels.py
import os

label_dirs = ["data36/train/labels", "data36/test/labels"]

for label_dir in label_dirs:
    for filename in os.listdir(label_dir):
        if filename.endswith(".txt"):
            filepath = os.path.join(label_dir, filename)
            with open(filepath) as f:
                lines = f.readlines()

            new_lines = []
            for line in lines:
                parts = line.strip().split()
                if len(parts) >= 13:
                    cls = parts[0]
                    # 提取4个关键点坐标 (索引5-12)
                    kpts = parts[5:13]
                    new_line = f"{cls} {' '.join(kpts)}\n"
                    new_lines.append(new_line)

            with open(filepath, "w") as f:
                f.writelines(new_lines)
```

---

<a id="2-模型结构修改"></a>

## 2. 模型结构修改

<a id="models-yolopy"></a>

### 文件: [`models/yolo.py`](../models/yolo.py)

#### Detect 类 `__init__` 方法

```python
# 原始
self.no = nc + 5  # 类别 + (x, y, w, h, obj)

# 修改后
self.no = nc + 5 + 4  # 类别 + 8个关键点坐标 + obj = nc + 9
```

#### Detect 类 `forward` 方法 (推理解码)

```python
# 原始 (矩形框解码)
xy = (xy.sigmoid() * 2 + self.grid[i]) * self.stride[i]
wh = (wh.sigmoid() * 2) ** 2 * self.anchor_grid[i]
y = torch.cat((xy, wh, conf.sigmoid()), 4)

# 修改后 (关键点解码)
kpts, conf = x[i].sigmoid().split((8, self.nc + 1), 4)
kpts_decoded = kpts.clone()
for p in range(4):
    kpts_decoded[..., p * 2] = (kpts[..., p * 2] * 2 - 0.5 + self.grid[i][..., 0]) * self.stride[i]
    kpts_decoded[..., p * 2 + 1] = (kpts[..., p * 2 + 1] * 2 - 0.5 + self.grid[i][..., 1]) * self.stride[i]
y = torch.cat((kpts_decoded, conf), 4)
```

---

<a id="3-数据加载修改"></a>

## 3. 数据加载修改

<a id="utils-dataloaderspy"></a>

### 文件: [`utils/dataloaders.py`](../utils/dataloaders.py)

#### 3.1 `verify_image_label` 函数

```python
# 原始: 检查 5 列 (cls, cx, cy, w, h)
assert lb.shape[1] == 5

# 修改后: 检查 9 列 (cls, x1, y1, x2, y2, x3, y3, x4, y4)
assert lb.shape[1] == 9
```

#### 3.2 `__getitem__` 方法 - Letterbox 缩放

```python
# 原始: 缩放矩形框
labels[:, 1:5] = xywhn2xyxy(labels[:, 1:5], ratio[0] * w, ratio[1] * h, padw, padh)

# 修改后: 缩放关键点
labels[:, 1::2] = labels[:, 1::2] * ratio[0] * w + pad[0]  # x坐标
labels[:, 2::2] = labels[:, 2::2] * ratio[1] * h + pad[1]  # y坐标
```

#### 3.3 `__getitem__` 方法 - 归一化

```python
# 原始
labels[:, 1:5] = xyxy2xywhn(labels[:, 1:5], w=img.shape[1], h=img.shape[0], clip=True, eps=1e-3)

# 修改后
labels[:, 1::2] = labels[:, 1::2] / img.shape[1]  # x归一化
labels[:, 2::2] = labels[:, 2::2] / img.shape[0]  # y归一化
labels[:, 1:9] = labels[:, 1:9].clip(0, 1)
```

#### 3.4 `__getitem__` 方法 - 翻转增强

```python
# 上下翻转
if random.random() < hyp["flipud"]:
    img = np.flipud(img)
    if nl:
        labels[:, 2::2] = 1 - labels[:, 2::2]  # y坐标翻转

# 左右翻转
if random.random() < hyp["fliplr"]:
    img = np.fliplr(img)
    if nl:
        labels[:, 1::2] = 1 - labels[:, 1::2]  # x坐标翻转
```

#### 3.5 `load_mosaic` 函数

类似的关键点缩放和裁剪逻辑修改。

---

<a id="4-数据增强修改"></a>

## 4. 数据增强修改

<a id="utils-augmentationspy"></a>

### 文件: [`utils/augmentations.py`](../utils/augmentations.py)

#### `random_perspective` 函数

```python
# 原始: 处理矩形框
targets[:, 1:5] = ...  # 变换 xywh

# 修改后: 处理关键点
kpts = targets[:, 1:9].reshape(-1, 2)  # (n*4, 2)
# 应用仿射变换
ones = np.ones((kpts.shape[0], 1))
kpts_homogeneous = np.hstack([kpts, ones])  # (n*4, 3)
kpts_t = kpts_homogeneous @ M.T  # 变换
kpts_t = kpts_t[:, :2] / kpts_t[:, 2:3]  # 齐次坐标转换
kpts_t = kpts_t.reshape(-1, 8)  # (n, 8)

# 从变换后的关键点计算边界框用于过滤
x_coords = kpts_t[:, 0::2]
y_coords = kpts_t[:, 1::2]
new_bboxes = np.stack([x_coords.min(1), y_coords.min(1), x_coords.max(1), y_coords.max(1)], axis=1)

# 过滤和裁剪
kpts_t[:, 0::2] = kpts_t[:, 0::2].clip(0, width)
kpts_t[:, 1::2] = kpts_t[:, 1::2].clip(0, height)
targets[:, 1:9] = kpts_t
```

---

<a id="5-损失函数修改"></a>

## 5. 损失函数修改

<a id="utils-losspy"></a>

### 文件: [`utils/loss.py`](../utils/loss.py)

#### `build_targets` 函数

```python
# 原始格式: targets = [img_idx, cls, cx, cy, w, h] (6列)
# 修改后格式: targets = [img_idx, cls, x1, y1, x2, y2, x3, y3, x4, y4] (10列)

# 从关键点计算边界框用于 anchor 匹配
kpts = t[:, 2:10]  # 8个坐标
x_coords = kpts[:, 0::2]
y_coords = kpts[:, 1::2]
bbox_cx = x_coords.mean(1)
bbox_cy = y_coords.mean(1)
bbox_w = x_coords.max(1)[0] - x_coords.min(1)[0]
bbox_h = y_coords.max(1)[0] - y_coords.min(1)[0]

# 使用计算出的 bbox 进行 anchor 匹配
r = torch.stack([bbox_w, bbox_h], dim=1) / anchors[:, None]
```

#### 关键点损失计算

```python
# 关键点回归损失 (L1 或 Smooth L1)
pkpts = ps[:, 5:13]  # 预测的8个关键点坐标
tkpts = tbox[:, 4:12]  # 目标的8个关键点坐标
lkpt = F.smooth_l1_loss(pkpts, tkpts, reduction="mean")
```

---

<a id="6-多边形-iou-实现"></a>

## 6. 多边形 IoU 实现

<a id="utils-generalpy"></a>

### 文件: [`utils/general.py`](../utils/general.py)

#### 新增函数

```python
def polygon_area(poly):
    """计算多边形面积 (Shoelace公式)."""
    n = len(poly)
    area = 0.0
    for i in range(n):
        j = (i + 1) % n
        area += poly[i][0] * poly[j][1]
        area -= poly[j][0] * poly[i][1]
    return abs(area) / 2.0


def polygon_intersection(poly1, poly2):
    """计算两个多边形的交集 (Sutherland-Hodgman算法)."""
    output = list(poly1)
    for i in range(len(poly2)):
        if len(output) == 0:
            return []
        input_list = output
        output = []
        edge_start = poly2[i]
        edge_end = poly2[(i + 1) % len(poly2)]
        for j in range(len(input_list)):
            current = input_list[j]
            previous = input_list[j - 1]
            # ... 裁剪逻辑 ...
    return output


def polygon_iou_single(poly1, poly2):
    """计算两个四边形的IoU."""
    area1 = polygon_area(poly1)
    area2 = polygon_area(poly2)
    intersection = polygon_intersection(poly1, poly2)
    inter_area = polygon_area(intersection) if len(intersection) >= 3 else 0
    union_area = area1 + area2 - inter_area
    return inter_area / union_area if union_area > 0 else 0


def polygon_iou_batch(kpts1, kpts2):
    """批量计算多边形IoU矩阵."""
    n, m = kpts1.shape[0], kpts2.shape[0]
    iou_matrix = np.zeros((n, m))
    for i in range(n):
        poly1 = kpts1[i].reshape(4, 2)
        for j in range(m):
            poly2 = kpts2[j].reshape(4, 2)
            iou_matrix[i, j] = polygon_iou_single(poly1, poly2)
    return iou_matrix
```

---

<a id="7-nms-修改"></a>

## 7. NMS 修改

### 文件: [`utils/general.py`](../utils/general.py)

#### `non_max_suppression` 函数

```python
def non_max_suppression(..., polygon_nms_enabled=False):
    # 输出格式: [x1, y1, x2, y2, x3, y3, x4, y4, conf, cls]

    if polygon_nms_enabled:
        # 使用多边形 IoU 进行 NMS (精确但慢)
        keep = polygon_nms(kpts, scores, iou_thres)
    else:
        # 使用矩形框 IoU 进行 NMS (快速，训练时使用)
        # 从关键点计算 min/max 边界框
        x_coords = x[:, :8:2]
        y_coords = x[:, 1:8:2]
        boxes = torch.stack([x_coords.min(1)[0], y_coords.min(1)[0],
                            x_coords.max(1)[0], y_coords.max(1)[0]], dim=1)
        keep = torchvision.ops.nms(boxes, scores, iou_thres)
```

---

<a id="8-推理可视化修改"></a>

## 8. 推理可视化修改

<a id="detectpy"></a>

### 文件: [`detect.py`](../detect.py)

```python
# 原始: 绘制矩形框
annotator.box_label(xyxy, label, color=color)

# 修改后: 绘制四边形
kpts = det[:, :8]  # 8个关键点坐标
pts = kpts.reshape(4, 2).astype(int)
for k in range(4):
    pt1 = tuple(pts[k])
    pt2 = tuple(pts[(k + 1) % 4])
    cv2.line(im0, pt1, pt2, color, thickness=line_thickness)
```

#### 关键点缩放

```python
# 新增 scale_keypoints 函数
def scale_keypoints(img1_shape, kpts, img0_shape, ratio_pad=None):
    """将关键点从 img1_shape 缩放到 img0_shape."""
    if ratio_pad is None:
        gain = min(img1_shape[0] / img0_shape[0], img1_shape[1] / img0_shape[1])
        pad = ((img1_shape[1] - img0_shape[1] * gain) / 2, (img1_shape[0] - img0_shape[0] * gain) / 2)
    else:
        gain = ratio_pad[0][0]
        pad = ratio_pad[1]

    kpts[:, 0::2] = (kpts[:, 0::2] - pad[0]) / gain  # x
    kpts[:, 1::2] = (kpts[:, 1::2] - pad[1]) / gain  # y
    # 裁剪到图像边界
    kpts[:, 0::2] = kpts[:, 0::2].clamp(0, img0_shape[1])
    kpts[:, 1::2] = kpts[:, 1::2].clamp(0, img0_shape[0])
    return kpts
```

---

<a id="9-验证脚本修改"></a>

## 9. 验证脚本修改

<a id="valpy"></a>

### 文件: [`val.py`](../val.py)

#### 新增 `process_batch_polygon` 函数

```python
def process_batch_polygon(detections, labels, iouv):
    """使用多边形IoU评估检测结果."""
    correct = np.zeros((detections.shape[0], iouv.shape[0])).astype(bool)
    det_kpts = detections[:, :8].cpu().numpy()
    lbl_kpts = labels[:, 1:9].cpu().numpy()
    iou = torch.from_numpy(polygon_iou_batch(lbl_kpts, det_kpts)).to(detections.device)
    correct_class = labels[:, 0:1] == detections[:, 9]
    # ... 匹配逻辑 ...
    return torch.tensor(correct, dtype=torch.bool, device=iouv.device)
```

#### 目标缩放

```python
# 原始: 缩放矩形框
scale_boxes(im[si].shape[1:], tbox, shape, shapes[si][1])

# 修改后: 缩放关键点
scale_keypoints(im[si].shape[1:], tkpts, shape, shapes[si][1])
```

---

<a id="10-训练可视化修改"></a>

## 10. 训练可视化修改

<a id="utils-plotspy"></a>

### 文件: [`utils/plots.py`](../utils/plots.py)

#### `plot_images` 函数

```python
# 兼容两种格式
ncols = ti.shape[1]

if ncols >= 10:
    # 四点格式: 绘制四边形
    kpts = ti[:, 2:10]
    pts = kpts.reshape(4, 2).astype(int)
    for k in range(4):
        cv2.line(im, tuple(pts[k]), tuple(pts[(k + 1) % 4]), color, thickness)
else:
    # 原始格式: 绘制矩形框
    boxes = xywh2xyxy(ti[:, 2:6])
    annotator.box_label(box, label, color=color)
```

---

<a id="11-pytorch-警告修复"></a>

## 11. PyTorch 警告修复

<a id="trainpy"></a>

### 文件: [`train.py`](../train.py)

```python
# 原始 (已弃用)
with torch.cuda.amp.autocast(amp):
scaler = torch.cuda.amp.GradScaler(enabled=amp)

# 修改后
with torch.amp.autocast('cuda', enabled=amp):
scaler = torch.amp.GradScaler('cuda', enabled=amp)
```

---

<a id="12-文件修改总结"></a>

## 12. 文件修改总结

| 文件                                                  | 修改内容                         | 文档位置                                   |
| ----------------------------------------------------- | -------------------------------- | ------------------------------------------ |
| [`models/yolo.py`](../models/yolo.py)                 | Detect 层输出维度、推理解码      | [§2](#2-模型结构修改)                      |
| [`utils/dataloaders.py`](../utils/dataloaders.py)     | 标签解析、缩放、翻转增强         | [§3](#3-数据加载修改)                      |
| [`utils/augmentations.py`](../utils/augmentations.py) | random_perspective 关键点变换    | [§4](#4-数据增强修改)                      |
| [`utils/loss.py`](../utils/loss.py)                   | build_targets、关键点损失        | [§5](#5-损失函数修改)                      |
| [`utils/general.py`](../utils/general.py)             | 多边形 IoU、NMS、scale_keypoints | [§6](#6-多边形-iou-实现) [§7](#7-nms-修改) |
| [`detect.py`](../detect.py)                           | 四边形可视化                     | [§8](#8-推理可视化修改)                    |
| [`val.py`](../val.py)                                 | 多边形 IoU 评估                  | [§9](#9-验证脚本修改)                      |
| [`utils/plots.py`](../utils/plots.py)                 | 训练可视化兼容                   | [§10](#10-训练可视化修改)                  |
| [`train.py`](../train.py)                             | PyTorch 警告修复                 | [§11](#11-pytorch-警告修复)                |
| [`convert_labels.py`](../convert_labels.py)           | 标签格式转换工具 (新建)          | [§1](#1-数据集标签格式)                    |

---

<a id="13-使用方法"></a>

## 13. 使用方法

### 训练

```bash
python train.py --data data/data36.yaml --weights yolov5s.pt --img 640 --epochs 100 --batch-size 8
```

### 推理

```bash
python detect.py --weights runs/train/exp/weights/best.pt --source path/to/images --conf-thres 0.25
```

### 验证

```bash
python val.py --weights runs/train/exp/weights/best.pt --data data/data36.yaml
```

---

## 14. 注意事项

1. **标签顺序**: 4个关键点必须按固定顺序排列（如顺时针从左上角开始）
2. **mAP 指标**: 当前 mAP 基于多边形 IoU，可能偏低，以实际推理效果为准
3. **训练速度**: 使用矩形框 NMS 训练以保证速度，评估时可选多边形 NMS
4. **兼容性**: 修改后的代码向后兼容原始矩形框格式

---

_文档版本: 1.0_  
_最后更新: 2026-02-14_
